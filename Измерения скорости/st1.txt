Проведя несколько измерений я стал сомневаться в своем испытательном стенде. 
Один раз я ошибся и указал неправильный адрес сервиса, nginx ответил с ошибкой 404.
Скороть ответов слабо отличалась от ответов программы. Хотя я знаю, что выдать 404
намного проще, чем выполнить программу. Вероятно дело в испытательном стенде и он просто не
может выдавать больше запросов.

С помощью профайлера python3 -m cProfile -s time speed_metr.py я начал изучать свой тестовый стенд.
Начал дома, на своем нетбуке. Первое измерение дало вот такие результаты:

Общая скорость отправки - 7464.01109021118 запросов в секунду
скорость в одном потоке - 7464.01109021118 запросов в секунду
         99443 function calls (98649 primitive calls) in 1.985 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.463    0.463    1.986    1.986 speed_metr.py:1(<module>)
     1002    0.243    0.000    0.249    0.000 {built-in method open}
     2000    0.209    0.000    0.602    0.000 smev.py:94(change)
    20016    0.201    0.000    0.201    0.000 {method 'replace' of 'str' objects}
       27    0.098    0.004    0.098    0.004 {method 'acquire' of '_thread.lock' objects}
     2000    0.093    0.000    0.093    0.000 {built-in method localtime}
       63    0.043    0.001    0.043    0.001 {built-in method loads}
     2000    0.038    0.000    0.038    0.000 {built-in method strftime}

Видно, что больше всего времени занимает операция открытия файлов с примерами и операция replace (в модуле СМЭВ, она заменяет там стандартные поля и персданные)

Я решил отказаться от чтения заранее подготовленных файлов, генерить данные на лету. Т.к. команда replace тоже дорогая, то я заменил и постаралс убрать и ее - делаю в шаблоне замену СМЭВ полей, а потом через format вставку персональных данных. Вот какой результат получил:

Отправляли 1000 запросов в 1 потоков
потрачено времени 0.12436580657958984 сек
общая скорость отправки - 8040.795356077511 запросов в секунду
скорость в одном потоке - 8040.795356077511 запросов в секунду
         49509 function calls (48707 primitive calls) in 0.750 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.173    0.173    0.750    0.750 speed_metr.py:1(<module>)
       33    0.100    0.003    0.100    0.003 {method 'acquire' of '_thread.lock' objects}
       63    0.036    0.001    0.036    0.001 {built-in method loads}
      299    0.027    0.000    0.073    0.000 {built-in method __build_class__}
    12317    0.026    0.000    0.026    0.000 {method 'append' of 'list' objects}

Общее время выполнения намного сократилось, но скорость отправки серьезно не возросла. Не понял почему. Похоже все эта система потоков довольно медленная. Провожу изменения на 5т. примеров.

Отправляли 5000 запросов в 1 потоков
потрачено времени 0.2399744987487793 сек
общая скорость отправки - 20835.547218849788 запросов в секунду
скорость в одном потоке - 20835.547218849788 запросов в секунду
         75937 function calls (75135 primitive calls) in 1.025 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.212    0.212    1.025    1.025 speed_metr.py:1(<module>)
       33    0.206    0.006    0.206    0.006 {method 'acquire' of '_thread.lock' objects}
     5000    0.056    0.000    0.086    0.000 random.py:220(_randbelow)
     5000    0.050    0.000    0.146    0.000 random.py:250(choice)
       63    0.038    0.001    0.038    0.001 {built-in method loads}
    16317    0.034    0.000    0.034    0.000 {method 'append' of 'list' objects}
      299    0.025    0.000    0.076    0.000 {built-in method __build_class__}

Цифра намного выше, получается выгодно измерять не большом кол-ве, т.к. снижаются накладные расходы на создание потока. Пробую измерить на 8т.

потрачено времени 0.33629560470581055 сек
общая скорость отправки - 23788.59517655116 запросов в секунду
скорость в одном потоке - 23788.59517655116 запросов в секунду
         95896 function calls (95094 primitive calls) in 1.263 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
       33    0.311    0.009    0.311    0.009 {method 'acquire' of '_thread.lock' objects}
        1    0.237    0.237    1.263    1.263 speed_metr.py:1(<module>)
     8000    0.094    0.000    0.144    0.000 random.py:220(_randbelow)
     8000    0.084    0.000    0.245    0.000 random.py:250(choice)
    19317    0.045    0.000    0.045    0.000 {method 'append' of 'list' objects}

Нормально, вряд ли сервис будет работать быстрее. Пробую на 1, 3, 5 потоках в отладке.

Начинаю отправку в 1 потоков
Отправляли 8000 запросов в 1 потоков
потрачено времени 0.34516215324401855 сек
общая скорость отправки - 23177.512148454633 запросов в секунду
скорость в одном потоке - 23177.512148454633 запросов в секунду
Генерация примеров для 3 потоков заняла 0.965167760848999 сек
Начинаю отправку в 3 потоков
Отправляли 8000 запросов в 3 потоков
потрачено времени 0.9719011783599854 сек
общая скорость отправки - 8231.289536554978 запросов в секунду
скорость в одном потоке - 2743.763178851659 запросов в секунду
Генерация примеров для 5 потоков заняла 1.619940996170044 сек
Начинаю отправку в 5 потоков
Отправляли 8000 запросов в 5 потоков
потрачено времени 1.6433131694793701 сек
общая скорость отправки - 4868.213891655561 запросов в секунду
скорость в одном потоке - 973.6427783311123 запросов в секунду
         521742 function calls (520940 primitive calls) in 6.473 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
      135    2.912    0.022    2.912    0.022 {method 'acquire' of '_thread.lock' objects}
    72000    0.827    0.000    1.260    0.000 random.py:220(_randbelow)
        1    0.812    0.812    6.474    6.474 speed_metr.py:1(<module>)
    72000    0.715    0.000    2.128    0.000 random.py:250(choice)
   117840    0.287    0.000    0.287    0.000 {method 'getrandbits' of '_random.Random' objects}

В 1 поток одинаково, но после резкое уменьшение скорости - встало в блокировку. Оно и понятно у меня одно ядро, а отправка фактически не проводится, там все заглушено. Поэтому потому и блокировки. Ну ок, буду пробовать теперь с многоядерном процессоре дома. В конце тоже самое, но не в режиме отладки

Отправляли 8000 запросов в 1 потоков
потрачено времени 0.33548688888549805 сек
общая скорость отправки - 23845.939334846575 запросов в секунду
скорость в одном потоке - 23845.939334846575 запросов в секунду
Генерация примеров для 3 потоков заняла 0.23465991020202637 сек
Начинаю отправку в 3 потоков
Отправляли 8000 запросов в 3 потоков
потрачено времени 0.9535715579986572 сек
общая скорость отправки - 8389.511969914758 запросов в секунду
скорость в одном потоке - 2796.503989971586 запросов в секунду
Генерация примеров для 5 потоков заняла 0.3984231948852539 сек
Начинаю отправку в 5 потоков
Отправляли 8000 запросов в 5 потоков
потрачено времени 1.5684995651245117 сек
общая скорость отправки - 5100.415822789812 запросов в секунду
скорость в одном потоке - 1020.0831645579625 запросов в секунду  

немного быстрее, оно тоже понятно. Итого - вариант более-менее, буду пробовать его на 4 ядерном, 8000 запросов нормально.

